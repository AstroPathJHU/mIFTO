table.names.wholeslide, paths)
Tables.byimage <- tables.out$Tables.byimage
Tables.wholeslide <- tables.out$Tables.wholeslide
Image.IDs <- tables.out$Image.IDs
Tables.wholeslide$SN.Ratio <- NULL
Tables.wholeslide$T.Tests <- NULL
Tables.byimage$Histograms <- NULL
Tables.byimage$BoxPlots <- NULL
Tables.wholeslide$BoxPlots_90 <- Tables.wholeslide$BoxPlots
Tables.wholeslide$BoxPlots_95 <- Tables.wholeslide$BoxPlots
Tables.wholeslide$BoxPlots_98 <- Tables.wholeslide$BoxPlots
Tables.wholeslide$BoxPlots_99 <- Tables.wholeslide$BoxPlots
#
table.names.byimage <-c('SN.Ratio','T.Tests')
table.names.wholeslide<-c('Histograms','BoxPlots',
'BoxPlots_90','BoxPlots_95',
'BoxPlots_98', 'BoxPlots_99')
x <- 'T6'
y <- 1
q <- Image.IDs[[x]][[y]][[1]]
q
str = paste0(
'.*', x, '.*',titration.type.name, '_1to', Concentration[y],
'_.*\\[',q, '\\]'
)
str
pattern.in
pattern.in <- str
wd <- paths[[y]]
wd
Protocol
a <- ijtiff::read_tags(image_names,'all' )
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = T,
ignore.case = T
)
a <- ijtiff::read_tags(image_names,'all' )
view(a['description'])
View(a['description'])
View(a[[1]]['description'])
a[[1]]["description"]
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
pattern.match
result.match.1
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$2$description)
)
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a[[2]]$description)
)
result.match.1
regmatches(
a[[2]]$description, regexec(pattern.match,a[[2]]$description)
)
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
frame1 <- 3
regmatches(
a[[2]]$description, regexec(pattern.match,a$frame3$description)
)
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
frame1 <- 4
regmatches(
a[[2]]$description, regexec(pattern.match,a$frame3$description)
)
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
frame1 <- 4
regmatches(
a[[3]]$description, regexec(pattern.match,a$frame3$description)
)
pattern.match="\\<Marker\\>(.*?)\\<Marker\\>"
frame1 <- 4
regmatches(
a[[3]]$description, regexec(pattern.match,a$frame3$description)
)
pattern.match="\\<Marker\\>(.*?)\\<Marker\\>"
frame1 <- 1
regmatches(
a[[1]]$description, regexec(pattern.match,a$frame1$description)
)
pattern.match="\\<Marker\\>(.*?)\\<Marker\\>"
frame1 <- 2
frame2 <- 2
regmatches(
a[[frame2]]$description, regexec(pattern.match,a$frame1$description)
)
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
regexec(pattern.match,a$frame1$description)
regexec(pattern.match,a[$frame1[[2]]$description)
regexec(pattern.match,a[[frame1[[2]]$description)
regexec(pattern.match,a[[2]]$description)
regexec(pattern.match,a[[3]]$description)
regexec(pattern.match,a[[4]]$description)
regexec(pattern.match,a[[5]]$description)
results.match <- vector('matrix', length(a))
for (i.1 in 1:length(a)){
results.match[[i.1]] <- regmatches(
a[[i.1]]$description, regexec(pattern.match,a[[i.1]]$description)
)
}
results.match <- matrix(length(a), 1)
for (i.1 in 1:length(a)){
results.match[[i.1]] <- regmatches(
a[[i.1]]$description, regexec(pattern.match,a[[i.1]]$description)
)
}
a
results.match
length(image_names)
results.match <- matrix(length(a), 1)
a <- ijtiff::read_tags(image_names,'all' )
#
for (i.1 in 1:length(a)){
result.match.1 <- regmatches(
a[[i.1]]$description, regexec(pattern.match,a[[i.1]]$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
results.match[[i.1]] <- result.match.1
}
results.match
results.match[[end]]
results.match[[end(results.match)]]
err.val <- 0
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = T,
ignore.case = T
)
if (length(image_names) > 1){
err.val <- 1
return(list(err.val = err.val))
}
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
#
# get the names of the layers for the protocol type
#
Protocol <- 'IF'
if (Protocol  == 'IF'){
#
results.match <- matrix(length(a), 1)
a <- ijtiff::read_tags(image_names,'all' )
#
for (i.1 in 1:length(a)){
result.match.1 <- regmatches(
a[[i.1]]$description, regexec(pattern.match,a[[i.1]]$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
results.match[[i.1]] <- result.match.1
}
#
types <- results.match[[1:length(results.match)-1]]
} else if (Protocol == 'IHC') {
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
# extract the second value
result.match.2 <- regmatches(
a$frame2$description, regexec(pattern.match,a$frame2$description)
)
result.match.2 <- result.match.2[[1]][2]
result.match.2 <- substring(
result.match.2, 2, (nchar(result.match.2[[1]])-2)
)
types <- c(result.match.1, result.match.2)
}
#
results.match[1:length(results.match)-1]
if (Protocol  == 'IF'){
#
results.match <- matrix(length(a), 1)
a <- ijtiff::read_tags(image_names,'all' )
#
for (i.1 in 1:length(a)){
result.match.1 <- regmatches(
a[[i.1]]$description, regexec(pattern.match,a[[i.1]]$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
results.match[[i.1]] <- result.match.1
}
#
types <- results.match[1:length(results.match)-1]
#
} else if (Protocol == 'IHC') {
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
# extract the second value
result.match.2 <- regmatches(
a$frame2$description, regexec(pattern.match,a$frame2$description)
)
result.match.2 <- result.match.2[[1]][2]
result.match.2 <- substring(
result.match.2, 2, (nchar(result.match.2[[1]])-2)
)
types <- c(result.match.1, result.match.2)
}
#
m2 <- list()
#
# read each image in separately
#
for (count2 in 1:length(image_names)) {
v <- tiff::readTIFF(image_names[count2],native = F,all = T,as.is = F)
if (!(length(v)-1) == length(types)){
return(err.val = 15)
}
v <- v[1:length(types)]
names(v) <- types
m2 <- c(m2, list(v))
}
m2
Opal1
data.in <- tryCatch({
data.in <- mIFTO::tiff.list(paths[[y]], pattern.in = str, 'IF')
err.val <- data.in$err.val
if (!err.val == 0){
return(-1)
}
data.in$data.out
}, error = function(cond){
return(-1)
}, warning = function(cond){
return(-1)
}, finally = {})
#
if(length(data.in[[1]]) == 1){
stop('error in slide ', str)
}
data.in <- data.in[[1]]
names(data.in)
grepl(Opal1, nn)
nn <- names(data.in)
grepl(Opal1, nn)
d.v <- grepl(Opal1, nn)
data.in <- data.in[[d.v]]
d.v
?grepl
grepl(Opal1, nn, value = T)
grep(Opal1, nn, value = T)
d.v <- grep(Opal1, nn, value = T)
data.in <- data.in[[d.v]]
str =  paste0('.*', x, '.*',titration.type.name,
'_1to', Concentration[y], '[^0].*_component_data.tif')
#
cImage.IDs <-  list.files(paths[[y]],pattern = str, ignore.case = T)
cImage.IDs
a <- ijtiff::read_tags(cImage.IDs,'all' )
i.1 <- 1
a <- ijtiff::read_tags(cImage.IDs[[i.1]],'all' )
a <- ijtiff::read_tags(paste0(paths[y],'\\',cImage.IDs[[i.1]]), 'all' )
a
length(a)
paste0(
'Please check that slides were unmixed properly for ',
x, ' ', titration.type.name,'_1to', Concentration[y], ' ',
cImage.IDs[[i.1]])
paste0(
'Please check that slides were unmixed properly for ',
x, ' ', titration.type.name,'_1to', Concentration[y],
'; Image name: ',
cImage.IDs[[i.1]])
Protocol.layers <- 8
for (i.1 in 1:length(cImage.IDs)){
a <- ijtiff::read_tags(paste0(paths[y],'\\',cImage.IDs[[i.1]]), 'all' )
if (!length(a) - 1 == Protocol.layers){
modal_out <- shinyalert::shinyalert(
title =  paste0('Wrong unmixing protocol'),
text = paste0(
'Please check that slides were unmixed properly for ',
x, ' ', titration.type.name,'_1to', Concentration[y],
'; Image name: ',
cImage.IDs[[i.1]]),
type = 'error',
showConfirmButton = TRUE
)
err.val <- 13
return(list(err.val = err.val))
}
}
aste0(
'Wrong number of layers in image for unmixing protocol: ',
Protocol)
paste0(
'Wrong number of layers in image for unmixing protocol: ',
Protocol)
devtools::load_all()
out <- list()
pb.Object <- winProgressBar(
title = "0% Complete", label = 'Thinking',
min = 0,max = 100, width = 500)
pb.count = 1
out <- list()
out$Slide_ID = 'T6'
out$Antibody <- 'PD1'
out$Opal1 <- '650'
out$Concentration <- '250,500,1000'
out$Thresholds <- '3,5,6,.22'
out$protocol.type <- '7color'
#
out$Vars_pxp <- c('ihc.Pixels', 'Folders.Pixels')
out$Naming.convention<-TRUE
out$titration.type<-"Primary Antibody"
out$connected.pixels <- '1,1,1,1'
out$Polymer <- 'PV50'
devtools::load_all()
pb.count = 0; mIFTO::doupdate.pgbar(
pb.count, pb.Object, 'Browse For Folder')
outchecked <- mIFTO::check.vars(out)
err.val <- outchecked$err.val
if (err.val != 0) {
return(err.val)
}
wd <- outchecked$wd
Slide_Descript <- outchecked$Slide_ID
Antibody <- outchecked$Antibody
Opal1 <- outchecked$Opal1
Antibody_Opal <- outchecked$Antibody_Opal
Concentration <- outchecked$Concentration
Thresholds <- outchecked$Thresholds
num.of.tiles <- outchecked$num.of.tiles
flowout <- outchecked$flowout
ihc.logical <- outchecked$ihc.logical
folders.px <- outchecked$folders.px
if (ihc.logical){
ihc.connected.pixels <- outchecked$ihc.connected.pixels
ihc.Thresholds <- outchecked$ihc.Thresholds
}
Protocol <- outchecked$Protocol
paths <- outchecked$paths
titration.type.name <- outchecked$titration.type.name
connected.pixels <- outchecked$connected.pixels
#
rm(outchecked, out)
#
###########################
v <- mIFTO::create.dir(wd,'pixels', flowout)
time <- system.time(
Tables <- mIFTO::populate.tables(
Slide_Descript, Concentration, Antibody_Opal, Thresholds, Opal1,
flowout, Protocol, paths, titration.type.name, connected.pixels,
pb.count, pb.Object
)
)
mIFTO::generate.pxp.image.data()
mIFTO::generate.pxp.image.data
pb.step<-round(89/(2*length(Slide_Descript)
*length(Concentration)), digits=2)
#
table.names.byimage <-c('SN.Ratio','T.Tests','Histograms')
table.names.wholeslide<-c('SN.Ratio','T.Tests','Histograms','BoxPlots')
#
tables.out <- mIFTO::preallocate.tables(
Slide_Descript, Concentration, titration.type.name,
table.names.wholeslide, paths, Protocol)
err.val <- tables.out$err.val
if (err.val != 0) {
return(list(err.val = err.val))
}
#
Tables.byimage <- tables.out$Tables.byimage
Tables.wholeslide <- tables.out$Tables.wholeslide
Image.IDs <- tables.out$Image.IDs
Tables.wholeslide$SN.Ratio <- NULL
Tables.wholeslide$T.Tests <- NULL
Tables.byimage$Histograms <- NULL
Tables.byimage$BoxPlots <- NULL
Tables.wholeslide$BoxPlots_90 <- Tables.wholeslide$BoxPlots
Tables.wholeslide$BoxPlots_95 <- Tables.wholeslide$BoxPlots
Tables.wholeslide$BoxPlots_98 <- Tables.wholeslide$BoxPlots
Tables.wholeslide$BoxPlots_99 <- Tables.wholeslide$BoxPlots
#
table.names.byimage <-c('SN.Ratio','T.Tests')
table.names.wholeslide<-c('Histograms','BoxPlots',
'BoxPlots_90','BoxPlots_95',
'BoxPlots_98', 'BoxPlots_99')
#
rm(tables.out)
#
numcores <- parallel::detectCores()
if (numcores > 10){
numcores <- 10
}
#
#############reading images in and computing stats for all pairs##############
#
mIFTO::doupdate.pgbar(pb.count, pb.Object, 'Reading in Images')
Sys.sleep(0.5)
#
str1 = paste0("Processing ", x, ' 1:',Concentration[[y]])
pb.count <- pb.count + pb.step; pb.count2 <- round(pb.count, digits = 0);
mIFTO::doupdate.pgbar(pb.count2, pb.Object, paste0(
str1,' - Reading Tiffs and Generating Image Statistics - ',
length(Image.IDs[[x]][[y]])))
#
cl <- parallel::makeCluster(
getOption("cl.cores", numcores), useXDR = FALSE, methods = FALSE);
parallel::clusterEvalQ(cl, library(mIFTO));
#
mIFTO::parallel.invoke.gpxp(
Concentration, x, y, Image.IDs, Antibody_Opal,
titration.type.name, Thresholds, paths,
connected.pixels, flowout, Opal1, cl
)
devtools(uninstall('mIFTO'))
devtools::uninstall('mIFTO')
setwd('..')
devtools::uninstall('mIFTO')
setwd('mIFTO')
devtools::load_all()
mIFTO::parallel.invoke.gpxp(
Concentration, x, y, Image.IDs, Antibody_Opal,
titration.type.name, Thresholds, paths,
connected.pixels, flowout, Opal1, cl
)
cl
q
str = paste0(
'.*', x, '.*',titration.type.name, '_1to', Concentration[y],
'_.*\\[',q, '\\]'
)
#
# read that image in
#
data.in <- tryCatch({
data.in <- mIFTO::tiff.list(paths[[y]], pattern.in = str, 'IF')
err.val <- data.in$err.val
if (!err.val == 0){
return(-1)
}
data.in$data.out
}, error = function(cond){
return(-1)
}, warning = function(cond){
return(-1)
}, finally = {})
#
if(length(data.in[[1]]) == 1){
stop('error in slide ', str)
}
data.in <- data.in[[1]]
nn <- names(data.in)
d.v <- grep(Opal1, nn, value = T)
if (flowout == TRUE){
data.in.write <- vector('list',length(data.in))
for (i1 in 1:length(data.in)){
data.in.write[[i1]]<-as.numeric(unlist(data.in[[i1]]))
}
names(data.in.write) <- names(data.in)
str = paste0(
wd,'/Results.pixels/data/raw/flow_like_tables/',Antibody_Opal,'_',x,'_1to',
Concentration[y],'_[',q,'].csv')
data.table::fwrite(data.in.write, file=str,sep=',')
}
#
# select and store only the desired data
#
data.in <- data.in[[d.v]]
data.in
if ((length(connected.pixels) == 1) & (grepl('NA', connected.pixels))){
positivity.data <- mIFTO::define.image.positivity(
data.in,Thresholds[[x]][y],connected.pixels)
} else {
positivity.data <- mIFTO::define.image.positivity(
data.in,Thresholds[[x]][y],connected.pixels[[x]][y])
}
positivity.data.out <- lapply(
1:length(positivity.data),
function(x) c(positivity.data[[x]]))
#
small.tables<-list(
'SN.Ratio' = mIFTO::sn.ratio.calculations(
positivity.data,Concentration[y],x,q),
'T.Tests' = mIFTO::welch.t.test.calculations(
positivity.data,Concentration[y],x,q),
'Image.ID' = paste0(
'[',q,']'),
'Image' = positivity.data.out
)
