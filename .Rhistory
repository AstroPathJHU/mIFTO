#
ihc.Image.ID.fullstrings <- c(ihc.Image.ID.fullstrings,cImage.IDs)
}
ihc.Image.ID.fullstrings
ihc.paths
ihc.path
ihc.path
ihc.Image.IDs
x
z
z <- ihc.Image.IDs
z
z[[x]][[1]]
?list.files
str = paste0(
'.*', x, '.*_IHC',
'_.*\\[',z, '\\]'
)
str
z
z <- ihc.Image.IDs[[x]][[1]]
z
str = paste0(
'.*', x, '.*_IHC',
'_.*\\[',z, '\\]'
)
str
pattern.in <- str
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = TRUE
)
image_names
install.packages('ijtiff')
ijtiff(image_names,'all' )
ijtiff::read_tags(image_names,'all' )
z <- '49653,11629'
str = paste0(
'.*', x, '.*_IHC',
'_.*\\[',z, '\\]'
)
pattern.in <- str
str
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = T,
ignore.case = T
)
image_names
pattern.in
wd
x <- 'T6'
str = paste0(
'.*', x, '.*_IHC',
'_.*\\[',z, '\\]'
)
pattern.in <- str
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = T,
ignore.case = T
)
image_names
ijtiff::read_tags(image_names,'all' )
a <- ijtiff::read_tags(image_names,'all' )
grepl
grepl('DAB', a)
View(a)
grepl('DAB', a, ignore.case = T)
grepl('Hematoxylin', a, ignore.case = T)
a$frame1$description
grepl('Name', a$frame1$description)
gregexpr('<NAME>', a)
?gregexpr
gregexpr('<NAME>', a$frame1$description)
gregexpr('<NAME>', a$frame1$description)[[1]][1]
pattern="<NAME>\\s*(.*?)\\s*<NAME>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
pattern="\<NAME\>\\s*(.*?)\\s*\<NAME\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
pattern="\\<NAME\\>(.*?)\\<NAME\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
pattern
pattern="<NAME>(.*?)<NAME>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
pattern="\\<NAME\\>(.*?)\\<NAME\\>"
regexec(pattern,a$frame1$description)
a$frame1$description
result
pattern="\\<NAME\\>(.*?)\\<NAME\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
stringr::str_match(a$frame1$description, pattern)
pattern="\\<Name\\>(.*?)\\<Name\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
result[[1]][2]
pattern="\\<Name\\>(.*?)\\</Name\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
pattern="\\<Name\\>(.*?)\\<\/Name\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
pattern="\\<Name\\>(.*?)\\<\\Name\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
?regmatches
regexec(pattern,a$frame1$description)
?regexec
pattern="\\<Name\\>(.*?)\\<"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
pattern="\\<NAME\\>(.*?)\\<\\/NAME\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
pattern
pattern="\\<NAME\\>\\s*(.*?)\\s*\\<\\/NAME\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
pattern="\\<NAME\\>\\s*(.*?)\\s*\\<NAME\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
pattern="\\<NAME\\>(.*?)\\<NAME\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result
# extract the initial position
pattern="\\<Name\\>(.*?)\\<Name\\>"
result <- regmatches(
a$frame1$description, regexec(pattern,a$frame1$description)
)
result[[1]][2]
result.match.1 <- result.match.1[2:(length(results.match.1)-2)]
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- result.match.1[2:(length(results.match.1)-2)]
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- result.match.1[2:(length(result.match.1)-2)]
result.match.1
result.match.1[2:(length(result.match.1[[1]])-2)]
(length(result.match.1[[1]])-2)
length(result.match.1[[1]])
result.match.1
result.match.1[[1]]
(nchar(result.match.1[[1]])-2)
result.match.1[2:(nchar(result.match.1[[1]])-2)]
substring(result.match.1, 2, (nchar(result.match.1[[1]])-2))
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
# extract the second value
result.match.2 <- regmatches(
a$frame2$description, regexec(pattern.match,a$frame2$description)
)
result.match.2 <- result.match.2[[1]][2]
result.match.2 <- substring(
result.match.2, 2, (nchar(result.match.2[[1]])-2)
)
result.match.2
err.val <- 0
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = T,
ignore.case = T
)
#
# get the names of the layers for the protocol type
#
if (Protocol  == '7color'){
types <- c('DAPI', '520', '540', '570', '620', '650', '690', 'AF')
} else if (Protocol == '9color'){
types <- c('DAPI','480', '520', '540', '570', '620',
'650', '690','780', 'AF')
} else if (Protocol == 'IHC') {
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
# extract the second value
result.match.2 <- regmatches(
a$frame2$description, regexec(pattern.match,a$frame2$description)
)
result.match.2 <- result.match.2[[1]][2]
result.match.2 <- substring(
result.match.2, 2, (nchar(result.match.2[[1]])-2)
)
types <- c(result.match.1, result.match.2)
}
#
m2 <- list()
#
# read each image in separately
#
for (count2 in 1:length(image_names)) {
v <- tiff::readTIFF(image_names[count2],native = F,all = T,as.is = F)
if (!(length(v)-1) == length(types)){
return(err.val = 15)
}
v <- v[1:length(types)]
names(v) <- types
m2 <- c(m2, list(v))
}
types
Protocol <- IHC
Protocol <- 'IHC'
err.val <- 0
image_names <- list.files(
wd,
pattern = paste0(pattern.in, '_component_data.tif'),
full.names = T,
ignore.case = T
)
#
# get the names of the layers for the protocol type
#
if (Protocol  == '7color'){
types <- c('DAPI', '520', '540', '570', '620', '650', '690', 'AF')
} else if (Protocol == '9color'){
types <- c('DAPI','480', '520', '540', '570', '620',
'650', '690','780', 'AF')
} else if (Protocol == 'IHC') {
a <- ijtiff::read_tags(image_names,'all' )
# extract the initial value
pattern.match="\\<Name\\>(.*?)\\<Name\\>"
result.match.1 <- regmatches(
a$frame1$description, regexec(pattern.match,a$frame1$description)
)
result.match.1 <- result.match.1[[1]][2]
result.match.1 <- substring(
result.match.1, 2, (nchar(result.match.1[[1]])-2)
)
# extract the second value
result.match.2 <- regmatches(
a$frame2$description, regexec(pattern.match,a$frame2$description)
)
result.match.2 <- result.match.2[[1]][2]
result.match.2 <- substring(
result.match.2, 2, (nchar(result.match.2[[1]])-2)
)
types <- c(result.match.1, result.match.2)
}
#
m2 <- list()
for (count2 in 1:length(image_names)) {
v <- tiff::readTIFF(image_names[count2],native = F,all = T,as.is = F)
if (!(length(v)-1) == length(types)){
return(err.val = 15)
}
v <- v[1:length(types)]
names(v) <- types
m2 <- c(m2, list(v))
}
types
image_names
devtools::load_all()
devtools::load_all()
data.in <- mIFTO::tiff.list(ihc.path, pattern.in = str, 'IHC')
data.in <- tryCatch({
data.in <- mIFTO::tiff.list(ihc.path, pattern.in = str, 'IHC')
err.val <- data.in$err.val
if (!err.val == 0){
return(-1)
}
data.in$data.out
}, error = function(cond){
return(-1)
}, warning = function(cond){
return(-1)
}, finally = {})
#
if(length(data.in[[1]]) == 1){
stop('error in slide ', str)
}
data.in <- data.in[[1]]
data.in <- data.in['DAB']
ihc.connected.pixels[[x]]
ihc.Thresholds[[x]]
str = paste0(
'.*', x, '.*_IHC',
'_.*\\[',z, '\\]'
)
#
# read in image data
#
data.in <- tryCatch({
data.in <- mIFTO::tiff.list(ihc.path, pattern.in = str, 'IHC')
err.val <- data.in$err.val
if (!err.val == 0){
return(-1)
}
data.in$data.out
}, error = function(cond){
return(-1)
}, warning = function(cond){
return(-1)
}, finally = {})
#
if(length(data.in[[1]]) == 1){
stop('error in slide ', str)
}
data.in <- data.in[[1]]
#
data.in <- data.in['DAB']
pos <- define.image.positivity(data.in, ihc.Thresholds[[x]],ihc.connected.pixels[[x]])
#
str = paste0(
'.*', x, '.*_IHC',
'_.*\\[',z, '\\]'
)
#
# read in image data
#
data.in <- tryCatch({
data.in <- mIFTO::tiff.list(ihc.path, pattern.in = str, 'IHC')
err.val <- data.in$err.val
if (!err.val == 0){
return(-1)
}
data.in$data.out
}, error = function(cond){
return(-1)
}, warning = function(cond){
return(-1)
}, finally = {})
#
if(length(data.in[[1]]) == 1){
stop('error in slide ', str)
}
data.in <- data.in[[1]]
#
data.in <- data.in[['DAB']]
pos <- define.image.positivity(data.in, ihc.Thresholds[[x]],ihc.connected.pixels[[x]])
sum(pos>0)
sum(pos[[1]]>0)
ihc.Thresholds[[1]]<-3.4
ihc.Thresholds[[1]]<-1.4
ihc.Thresholds[[2]]<-1.4
ihc.Thresholds[[3]]<-1.4
pos <- define.image.positivity(data.in, ihc.Thresholds[[x]],ihc.connected.pixels[[x]])
sum(pos[[1]]>0)
ihc.Thresholds
ihc.Thresholds <- .4
ihc.Thresholds[[1]] <- .4
ihc.Thresholds[[2]] <- .4
ihc.Thresholds[[3]] <- .4
pos <- define.image.positivity(data.in, ihc.Thresholds[[x]],ihc.connected.pixels[[x]])
names(ihc.Thresholds)<-Slide_Descript
pos <- define.image.positivity(data.in, ihc.Thresholds[[x]],ihc.connected.pixels[[x]])
sum(pos[[1]]>0)
rasterImage(pos.mask)
rasterImage(pos$pos.mask)
rasterImage(pos$pos.mask, 1, 1, 1004, 1344)
plot(0:1,0:1,type="n",ann=FALSE,axes=FALSE)
rasterImage(pos$pos.mask,0,0,1,1)
sum(pos.mask[[1]]>0)
sum(pos$pos.mask[[1]]>0)
sum(pos[[1]]>0)
sum(pos$pos.mask[[1]]==1)
length(pos$pos.mask[[1]]==1)
pos$pos.mask[[1]]==1
pos$pos.mask==1
length(pos$pos.mask==1)
sum(pos$pos.mask)
Positivity.Inside <- cbind.data.frame(
fraction = sum(pos$pos.mask) / length(pos$pos.mask), Slide.ID = x,
Image.ID = z
)
Positivity.Inside
for (x in Slide_Descript){
time <- system.time({
cl <- parallel::makeCluster(
getOption("cl.cores", numcores), useXDR = FALSE, methods = FALSE);
parallel::clusterEvalQ(cl, library(mIFTO));
#
ihc.small.tables.byimage <- tryCatch({
mIFTO::ihc.parallel.invoke.gpxp(
ihc.path, x, ihc.Image.IDs, ihc.Thresholds,
ihc.connected.pixels, cl
)
}, warning = function(cond) {
modal_out <- shinyalert::shinyalert(
title = paste0('Error Reading Component Images for ',
x, ' IHC'),
text = paste0('Please check the computer reasources, slide names, ',
'image layers correspond to protocol type, ',
'and that component data tiffs for ', x,
' IHC exist. Then contact ',
'Benjamin Green at bgreen42jh.edu for assistance.'),
type = 'error',
showConfirmButton = TRUE
)
err.val <- 15
return(err.val)
}, error = function(cond) {
modal_out <- shinyalert::shinyalert(
title = paste0('Error Reading Component Images for ',
x, ' IHC'),
text = paste0('Please check the computer reasources, slide names, ',
'image layers correspond to protocol type, ',
'and that component data tiffs for ', x,
' IHC exist. Then contact ',
'Benjamin Green at bgreen42jh.edu for assistance.'),
type = 'error',
showConfirmButton = TRUE
)
err.val <- 15
return(err.val)
},
finally={
parallel::stopCluster(cl)
})
#
if (length(ihc.small.tables.byimage) == 1) {
err.val <- 15
return(list(err.val = err.val))
}
})
}
numcores <- parallel::detectCores()
if (numcores > 10){
numcores <- 10
}
#
cl <- parallel::makeCluster(
getOption("cl.cores", numcores), useXDR = FALSE, methods = FALSE);
parallel::clusterEvalQ(cl, library(mIFTO));
#
mIFTO::ihc.parallel.invoke.gpxp(
ihc.path, x, ihc.Image.IDs, ihc.Thresholds,
ihc.connected.pixels, cl
)
devtools::document()
devtools::load_all()
cl <- parallel::makeCluster(
getOption("cl.cores", numcores), useXDR = FALSE, methods = FALSE);
parallel::clusterEvalQ(cl, library(mIFTO));
#
mIFTO::ihc.parallel.invoke.gpxp(
ihc.path, x, ihc.Image.IDs, ihc.Thresholds,
ihc.connected.pixels, cl
)
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
cl <- parallel::makeCluster(
getOption("cl.cores", numcores), useXDR = FALSE, methods = FALSE);
parallel::clusterEvalQ(cl, library(mIFTO));
#
mIFTO::ihc.parallel.invoke.gpxp(
ihc.path, x, ihc.Image.IDs, ihc.Thresholds,
ihc.connected.pixels, cl
)
devtools::install_github('beng1290/mIFTO','MergeSxP_2')
devtools::uninstall('mIFTO')
devtools::uninstall('c:/Users/beng1/Documents/R/win-library/4.0/mIFTO')
devtools::install_github('beng1290/mIFTO','MergeSxP_2')
devtools::install_github('beng1290/mIFTO','MergeSxP_2')
devtools::document()
devtools::install_github('beng1290/mIFTO','MergeSxP_2')
