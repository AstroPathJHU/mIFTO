install.packages(dplyr)
install.packages('dplyr')
install.packages(dplyr)
install.packages('dplyr')
install.packages('dplyr')
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.make("make")
install.packages('dplyr')
library(devtools)
library(roxygen2)
setwd('\\bki05\n$\bgcode2\R\mIFTO')
setwd('//bki05/n$/bgcode2/R/mIFTO')
document()
install.packages('data.table')
install.packages('tiff')
install.packages('gridExtra')
install.packages('gWidgets')
install.packages('gWidgetstclkl')
install.packages('gWidgetstcltk')
document()
load_all()
out <- list()
out$Slide_Descript = 'T6,T7,T8'
out$titration.type <- 'Primary'
out$Antibody <- 'PD1'
out$Concentration <- '250,500,1000,2000'
out$protocol.type <- '7color'
out$Opal1 <- '650'
out$Polymer <- 'PV50'
out$Naming.convention <- TRUE
out$Folders.pixels <- TRUE
out$IHC <- FALSE
out$nConsistent <- TRUE
out$ConnectedPixels <- '10'
out$Thresholds <- '3,4,5,6'
out$Thresholded <- TRUE
out$AB_Sparse <- FALSE
outchecked <- CheckVars(out)
wd <- outchecked$wd
Slide_Descript <- outchecked$Slide_Descript
flowout <- outchecked$flowout
Antibody <- outchecked$Antibody
Opal1 <- outchecked$Opal1
Antibody_Opal <- outchecked$Antibody_Opal
Concentration <- outchecked$Concentration
Thresholds <- outchecked$Thresholds
Protocol <- outchecked$Protocol
paths <- outchecked$paths
titration.type.name <- outchecked$titration.type.name
num.of.tiles <- outchecked$num.of.tiles
connected.pixels <- outchecked$connected.pixels
graph.out <- mIFTO::CreateMyTheme()
theme1 <- graph.out$theme1
colors <- graph.out$colors
#
xcoords<-c(min(Concentration)-((min(Concentration))/2),
max(Concentration)+((min(Concentration))/2))
mIFTO::CreateDir(wd,'pixels', flowout)
tables_out <- PreallocateTables(Slide_Descript,Concentration)
Tables <- tables_out$Tables
Image.IDs <- tables_out$Image.IDs
Violin.Plots <- tables_out$Violin.Plots
## need to add boxplots to by image version ##########################
table.names<-c('SN.Ratio','T.Tests','Histograms')
for(x in Slide_Descript){
for(y in 1:length(Concentration)){
#
# create a vector in Tables to store the data for each image
# separately
#
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]][[x]][[y]]<-vector(
'list',length(Image.IDs[[x]][[y]]))
}}
#
# update the progress bar
#
#pbi<-round(pbi1/length(Image.IDs[[x]][[y]]),digits=2)
#
# for each image gather the stats and return the images
# to reduce RAM usage the code does this one image at a time
# in addition parallel computing was implemented
# to speed this up. Though the actual RAM usage is quite low
# if I only carry the part of the image that is needed...
#
cl <- parallel::makeCluster(11)
parallel::clusterExport(
cl=cl, varlist=c("Concentration", "x", "y", "Antibody_Opal",
"titration.type.name","Protocol","Thresholds","paths",
"connected.pixels","flowout","Opal1","GeneratePxPData"),
envir=environment())
time <- system.time(
small.tables<- snow::parLapply(cl,Image.IDs[[x]][[y]],function(z)
GeneratePxPData(
Concentration, x, y, z, Antibody_Opal,
titration.type.name, Protocol, Thresholds, paths,
connected.pixels, flowout, Opal1))
)
snow::stopCluster(cl)
print(time[['elapsed']])
#
# reorganize to a table format to fit into the main 'Tables' list
#
All.Images <-list()
for (i.3 in 1:length(small.tables)){
for (i.1 in table.names){
for (i.2 in 1:length(Tables[[i.1]])){
Tables[[i.1]][[i.2]][[x]][[y]][[i.3]] <- small.tables[[i.3]][[i.1]][[i.2]]
}}
#
# get the image data out for each image so that total slide-conc. pair metrics can be
# produced
#
All.Images <- c(All.Images,small.tables[[i.3]][[5]])
}
#  IC.plots <- IC.Plots.Calculations(
#    f,data.in,Opal1,Concentration,Thresholds,x,y,colors)
# #
# # #do the calculations for each type of graph and store
# #
#  small.tables <- list('SN.Ratio' = SN.Ratio.Calculations(
#    data.in,Opal1,Concentration,Thresholds,x,y),
#    'T.Tests' = T.Test.Calculations(
#      data.in,Opal1,Concentration,Thresholds,x,y),
#    'Histograms' = Histogram.Calculations(
#      data.in, Opal1,Concentration,Thresholds,x,y),
#    'BoxPlots'= IC.plots[['Boxplot.Calculations']])
# #
# #the rest of the loop moves the data into a format that allows
# #the data to be more readily available
#
# Violin.Plots[[x]][[y]]<-IC.plots[['Violin.Calculations']]
#
# reorganize the data into a workable format for building graphs later
# essentially turning the list into a data table
#
for(i.1 in table.names){
for(i.2 in 1:length(Tables[[i.1]])){
Tables[[i.1]][[i.2]][[x]][[y]]<-do.call(
rbind.data.frame,Tables[[i.1]][[i.2]][[x]][[y]])
}}
}
#
# for each Analysis Table in 'Tables'
# pair the data down into a data
#
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]][[x]]<-do.call(
rbind.data.frame,Tables[[i.1]][[w]][[x]])}}
}
#
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]]<-do.call(
rbind.data.frame,Tables[[i.1]][[w]])}}
install.packages('snow')
for(x in Slide_Descript){
for(y in 1:length(Concentration)){
#
# create a vector in Tables to store the data for each image
# separately
#
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]][[x]][[y]]<-vector(
'list',length(Image.IDs[[x]][[y]]))
}}
#
# update the progress bar
#
#pbi<-round(pbi1/length(Image.IDs[[x]][[y]]),digits=2)
#
# for each image gather the stats and return the images
# to reduce RAM usage the code does this one image at a time
# in addition parallel computing was implemented
# to speed this up. Though the actual RAM usage is quite low
# if I only carry the part of the image that is needed...
#
cl <- parallel::makeCluster(11)
parallel::clusterExport(
cl=cl, varlist=c("Concentration", "x", "y", "Antibody_Opal",
"titration.type.name","Protocol","Thresholds","paths",
"connected.pixels","flowout","Opal1","GeneratePxPData"),
envir=environment())
time <- system.time(
small.tables<- snow::parLapply(cl,Image.IDs[[x]][[y]],function(z)
GeneratePxPData(
Concentration, x, y, z, Antibody_Opal,
titration.type.name, Protocol, Thresholds, paths,
connected.pixels, flowout, Opal1))
)
snow::stopCluster(cl)
print(time[['elapsed']])
#
# reorganize to a table format to fit into the main 'Tables' list
#
All.Images <-list()
for (i.3 in 1:length(small.tables)){
for (i.1 in table.names){
for (i.2 in 1:length(Tables[[i.1]])){
Tables[[i.1]][[i.2]][[x]][[y]][[i.3]] <- small.tables[[i.3]][[i.1]][[i.2]]
}}
#
# get the image data out for each image so that total slide-conc. pair metrics can be
# produced
#
All.Images <- c(All.Images,small.tables[[i.3]][[5]])
}
#  IC.plots <- IC.Plots.Calculations(
#    f,data.in,Opal1,Concentration,Thresholds,x,y,colors)
# #
# # #do the calculations for each type of graph and store
# #
#  small.tables <- list('SN.Ratio' = SN.Ratio.Calculations(
#    data.in,Opal1,Concentration,Thresholds,x,y),
#    'T.Tests' = T.Test.Calculations(
#      data.in,Opal1,Concentration,Thresholds,x,y),
#    'Histograms' = Histogram.Calculations(
#      data.in, Opal1,Concentration,Thresholds,x,y),
#    'BoxPlots'= IC.plots[['Boxplot.Calculations']])
# #
# #the rest of the loop moves the data into a format that allows
# #the data to be more readily available
#
# Violin.Plots[[x]][[y]]<-IC.plots[['Violin.Calculations']]
#
# reorganize the data into a workable format for building graphs later
# essentially turning the list into a data table
#
for(i.1 in table.names){
for(i.2 in 1:length(Tables[[i.1]])){
Tables[[i.1]][[i.2]][[x]][[y]]<-do.call(
rbind.data.frame,Tables[[i.1]][[i.2]][[x]][[y]])
}}
}
#
# for each Analysis Table in 'Tables'
# pair the data down into a data
#
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]][[x]]<-do.call(
rbind.data.frame,Tables[[i.1]][[w]][[x]])}}
}
#
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]]<-do.call(
rbind.data.frame,Tables[[i.1]][[w]])}}
warnings()
x
y
for(i.1 in table.names){
for(w in 1:length(Tables[[i.1]])){
Tables[[i.1]][[w]][[x]][[y]]<-vector(
'list',length(Image.IDs[[x]][[y]]))
}}
install.packages("snow")
install.packages("snow")
Image.IDs[[x]][[y]]
Concentration
z
Antibody_Opal
titration.type.name
Protocol
Thresholds
paths
connected.pixels
flowout
Opal1
flowout == TRUE
if (flowout == TRUE){
data.in.write <- vector('list',length(data.in))
for (i1 in 1:length(data.in)){
data.in.write[[i1]]<-as.numeric(unlist(data.in[[i1]]))
}
names(data.in.write) <- names(data.in)
str = paste0(
wd,'/Results.pixels/flow_like_tables/csv/',Antibody_Opal,'_',x,'_1to',
Concentration[y],'_[',q,'].csv')
data.table::fwrite(data.in.write, file=str,sep=',')
}
cl <- parallel::makeCluster(11)
parallel::clusterExport(
cl=cl, varlist=c("Concentration", "x", "y", "Antibody_Opal",
"titration.type.name","Protocol","Thresholds","paths",
"connected.pixels","flowout","Opal1","GeneratePxPData"),
envir=environment())
time <- system.time(
small.tables<- snow::parLapply(cl,Image.IDs[[x]][[y]],function(z)
GeneratePxPData(
Concentration, x, y, z, Antibody_Opal,
titration.type.name, Protocol, Thresholds, paths,
connected.pixels, flowout, Opal1))
)
snow::stopCluster(cl)
print(time[['elapsed']])
warnings()
q <- Image.IDs[[x]][[y]]
str = paste0(
'.*', x, '.*',titration.type.name, '_1to', Concentration[y],
'_.*\\[',q, '\\]'
)
tryCatch({
data.in <- mIFTO::tiff.list(paths[[y]], pattern.in = str, Protocol)
}, error = function(cond){
message(paste0(' Search failed for ', str, ';'))
stop(paste0('Please check slide names and check that files for ',
x, ' 1to',Concentration[[y]],' exist'), call. = F)
}, finally = {})
if(length(data.in) != 1){
message('Error in Slide names or input')
stop(paste0('Search for', str,' turned up more than one image'),
call. = FALSE)
}
data.in <- data.in[[1]]
if (flowout == TRUE){
data.in.write <- vector('list',length(data.in))
for (i1 in 1:length(data.in)){
data.in.write[[i1]]<-as.numeric(unlist(data.in[[i1]]))
}
names(data.in.write) <- names(data.in)
str = paste0(
wd,'/Results.pixels/flow_like_tables/csv/',Antibody_Opal,'_',x,'_1to',
Concentration[y],'_[',q,'].csv')
data.table::fwrite(data.in.write, file=str,sep=',')
}
data.in <- data.in[[Opal1]]
#
# get the positvity data
#
positivity.data <- mIFTO::DefineImagePositivity(data.in,Thresholds[y],connected.pixels[y])
#
# do the calculations for each type of graph and store
#
small.tables<-list(
'SN.Ratio' = mIFTO::SN.Ratio.Calculations(
positivity.data,Concentration,x,y,q),
'T.Tests' = mIFTO::T.Test.Calculations(
positivity.data,Concentration,x,y,q),
'Histograms' = mIFTO::Histogram.Calculations(
data.in,Concentration,x,y,q),
'Image.ID' = paste0(
'[',q,']'),
'Image' = data.in
)
positivity.data
positivity.data <- mIFTO::DefineImagePositivity(data.in,Thresholds[y],connected.pixels[y])
#
install.packages('EBImages')
install.packages("BiocManager")
a<-installed.packages()
packages<-a[,1]
if (!is.element("EBImages", packages))
BiocManager::install("EBImage")
Bioconductor::EBImages
BiocManager::EBImages
document()
document()
document()
install.packages(reshape2)
install.packages('reshape2')
if (!is.element("EBImages", packages))
BiocManager::install("EBImage")
install.packages('backports')
install.packages("backports")
install.packages('boot')
class, foreign, KernSmooth, MASS, nnet, spatial
install.packages('class')
install.packages('foreign')
install.packages('kern')
install.packages('KernSmooth')
install.packages('MASS')
install.packages('nnet')
install.packages('spatial')
a<-installed.packages()
packages<-a[,1]
if (!is.element("EBImages", packages))
BiocManager::install("EBImage")
end
